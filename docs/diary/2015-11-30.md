# 2015 11 30 월요일

- [일기 목록](../Diary.md)

### 오늘의 한일

 - Reactjs 스프링 샘플 어플리케이션 만들기

리액트JS 샘플 어플리케이션을 제작하면서 프레임웤 제작에 대한 전제적인 뷰를 좀 더 생각해보기로 하였다.

샘플 어플리케이션 코드는 아래 링크에 있다.
 - [react-spring-sample](https://github.com/SeungpilPark/metaworks4/tree/master/react-spring-sample)


#### 코멘트 입력, 리스트 출력의 간단한 플로우

아래 코드는 코멘트를 입력받고 리스트를 출력하는 짧은 패턴을 리액트로 구현 한 것이다.


 - index.jsp
```

<%@ page contentType="text/html; charset=UTF-8" language="java" trimDirectiveWhitespaces="true" %>

<%@ taglib prefix="spring" uri="http://www.springframework.org/tags" %>
<%@ taglib prefix="uengine" uri="http://www.uengine.io/tags" %>
<!DOCTYPE html>
<!--[if IE 9]> <html lang="en" class="ie9"> <![endif]-->
<!--[if IE 8]> <html lang="en" class="ie8"> <![endif]-->
<!--[if !IE]><!-->
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:th="http://www.thymeleaf.org"
      xmlns:sec="http://www.thymeleaf.org"
      lang="en">
<!--<![endif]-->
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title></title>

    <script src="/resources/react/react.js"></script>
    <script src="/resources/react/react-dom.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/babel-core/5.8.23/browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/marked/0.3.2/marked.min.js"></script>
</head>

<body>
<div id="content"></div>
<script type="text/babel" src="/resources/scripts/example.js"></script>
<script type="text/babel">
    // To get started with this tutorial running your own code, simply remove
    // the script tag loading scripts/example.js and start writing code here.
</script>
</body>

</html>


```


 - /api/comments.json
```

[
  {"id":1,"author": "Pete Hunt", "text": "This is one comment"},
  {"id":2,"author": "Jordan Walke", "text": "This is *another* comment"}
]

```


/scripts/example.js

```
var Comment = React.createClass({
        rawMarkup: function() {
            var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
            return { __html: rawMarkup };
        },
        render: function() {
            return (
                <div className="comment">
                    <h2 className="commentAuthor">
                    {this.props.author}
                    </h2>
                    <span dangerouslySetInnerHTML={this.rawMarkup()} />
                </div>
            );
        }
});


var CommentList = React.createClass({
    render: function() {
        var commentNodes = this.props.data.map(function(comment) {
            return (
                <Comment author={comment.author} key={comment.id}>
                    {comment.text}
                </Comment>
                );
            });
        return (
            <div className="commentList">
                {commentNodes}
            </div>
        );
    }
});

var CommentForm = React.createClass({
    getInitialState: function() {
        return {author: '', text: ''};
    },
    handleAuthorChange: function(e) {
        this.setState({author: e.target.value});
    },
    handleTextChange: function(e) {
        this.setState({text: e.target.value});
    },
    handleTextClick: function(e){
        console.log('click!');
    },
    handleSubmit: function(e) {
        e.preventDefault();
        var author = this.state.author.trim();
        var text = this.state.text.trim();
        if (!text || !author) {
            return;
        }
        // TODO: send request to the server
        this.props.onCommentSubmit({author: author, text: text});
        this.setState({author: '', text: ''});
    },
    render: function() {
        return (
            <form className="commentForm" onSubmit={this.handleSubmit}>
            <input
            type="text"
            placeholder="Your name"
            value={this.state.author}
            onChange={this.handleAuthorChange}
            />
            <input
            type="text"
            placeholder="Say something..."
            value={this.state.text}
            onChange={this.handleTextChange}
            onClick={this.handleTextClick}
            />
            <input type="submit" value="Post" />
    </form>
        );
    }
});

var CommentBox = React.createClass({
    loadCommentsFromServer: function() {
        console.log('call comment');
        $.ajax({
            url: this.props.url,
            dataType: 'json',
            cache: false,
            success: function(data) {
                this.setState({data: data});
            }.bind(this),
            error: function(xhr, status, err) {
                console.error(this.props.url, status, err.toString());
            }.bind(this)
        });
    },
    handleCommentSubmit: function(comment) {
        var comments = this.state.data;
        // Optimistically set an id on the new comment. It will be replaced by an
        // id generated by the server. In a production application you would likely
        // not use Date.now() for this and would have a more robust system in place.
        comment.id = Date.now();
        var newComments = comments.concat([comment]);
        this.setState({data: newComments});

        // TODO: submit to the server and refresh the list
        console.log(comment);
        console.log('handleCommentSubmit');
    },
    getInitialState: function() {
        return {data: []};
    },
    componentDidMount: function() {
        this.loadCommentsFromServer();
    },
    render: function() {
        return (
            <div className="commentBox">
            <h1>Comments</h1>
            <CommentList data={this.state.data} />
            <CommentForm onCommentSubmit={this.handleCommentSubmit} />
            </div>
        );
    }
});


ReactDOM.render(
    <CommentBox url="/resources/api/comments.json" />,
    document.getElementById('content')
);


```

컴포넌트 종속관계가 많아지고 기능이 추가될 수록 JSX 를 쓰지 않으니 가독성이 힘들다.
JSX 를 쓸 경우 그나마 보기가 편안해지고 코딩량이 많이 줄어든다.

JSX 로 개발을 한 후 컴파일을 할 때 웹상에서 바로 코드보기를 원할 경우 아래 사이트가 도움이 되었다.

 - [Babel react - jsx compiler online](http://babeljs.io/repl/)
 
위의 사이트에서 컴파일 한 js 파일이다. 

```
"use strict";

var data = [{ id: 1, author: "Pete Huntddd", text: "This is one comment" }, { id: 2, author: "Jordan Walke", text: "This is *another* comment" }];

var Comment = React.createClass({
    displayName: "Comment",

    rawMarkup: function rawMarkup() {
        var rawMarkup = marked(this.props.children.toString(), { sanitize: true });
        return { __html: rawMarkup };
    },
    render: function render() {
        return React.createElement(
            "div",
            { className: "comment" },
            React.createElement(
                "h2",
                { className: "commentAuthor" },
                this.props.author
            ),
            React.createElement("span", { dangerouslySetInnerHTML: this.rawMarkup() })
        );
    }
});

var CommentList = React.createClass({
    displayName: "CommentList",

    render: function render() {
        var commentNodes = this.props.data.map(function (comment) {
            return React.createElement(
                Comment,
                { author: comment.author, key: comment.id },
                comment.text
            );
        });
        return React.createElement(
            "div",
            { className: "commentList" },
            commentNodes
        );
    }
});

var CommentForm = React.createClass({
    displayName: "CommentForm",

    getInitialState: function getInitialState() {
        return { author: '', text: '' };
    },
    handleAuthorChange: function handleAuthorChange(e) {
        this.setState({ author: e.target.value });
    },
    handleTextChange: function handleTextChange(e) {
        this.setState({ text: e.target.value });
    },
    handleTextClick: function handleTextClick(e) {
        console.log('click!');
    },
    handleSubmit: function handleSubmit(e) {
        e.preventDefault();
        var author = this.state.author.trim();
        var text = this.state.text.trim();
        if (!text || !author) {
            return;
        }
        // TODO: send request to the server
        this.props.onCommentSubmit({ author: author, text: text });
        this.setState({ author: '', text: '' });
    },
    render: function render() {
        return React.createElement(
            "form",
            { className: "commentForm", onSubmit: this.handleSubmit },
            React.createElement("input", {
                type: "text",
                placeholder: "Your name",
                value: this.state.author,
                onChange: this.handleAuthorChange
            }),
            React.createElement("input", {
                type: "text",
                placeholder: "Say something...",
                value: this.state.text,
                onChange: this.handleTextChange,
                onClick: this.handleTextClick
            }),
            React.createElement("input", { type: "submit", value: "Post" })
        );
    }
});

var CommentBox = React.createClass({
    displayName: "CommentBox",

    loadCommentsFromServer: function loadCommentsFromServer() {
        console.log('call comment');
        $.ajax({
            url: this.props.url,
            dataType: 'json',
            cache: false,
            success: (function (data) {
                this.setState({ data: data });
            }).bind(this),
            error: (function (xhr, status, err) {
                console.error(this.props.url, status, err.toString());
            }).bind(this)
        });
    },
    handleCommentSubmit: function handleCommentSubmit(comment) {
        var comments = this.state.data;
        // Optimistically set an id on the new comment. It will be replaced by an
        // id generated by the server. In a production application you would likely
        // not use Date.now() for this and would have a more robust system in place.
        comment.id = Date.now();
        var newComments = comments.concat([comment]);
        this.setState({ data: newComments });

        // TODO: submit to the server and refresh the list
        console.log(comment);
        console.log('handleCommentSubmit');
    },
    getInitialState: function getInitialState() {
        return { data: [] };
    },
    componentDidMount: function componentDidMount() {
        this.loadCommentsFromServer();
    },
    render: function render() {
        return React.createElement(
            "div",
            { className: "commentBox" },
            React.createElement(
                "h1",
                null,
                "Comments"
            ),
            React.createElement(CommentList, { data: this.state.data }),
            React.createElement(CommentForm, { onCommentSubmit: this.handleCommentSubmit })
        );
    }
});

ReactDOM.render(React.createElement(CommentBox, { url: "/resources/api/comments.json" }), document.getElementById('content'));

```

React.createElement... 이 부분들이 가독성을 많이 떨어뜨리고 있다.



#### 리액트 컴포넌트 컨트롤링을 하다보니

일단.. 요즘 프레임웤들이 으례 그렇듯이 컴포넌트 객체의 변수값 (리액트는 state, 앵귤러는 scope 로 표현한다.) 이 갱신되는대로

DOM 에 자동갱신되는 구조이다. 변수 접근 감지를 어떻게 하는지는 잘 모르겠지만.. 일단 몰라도 잘 쓰니 깊게 생각해 본 적이 없다.

기능 구현을 위해 쓸데없이 많은 way를 제공하지 않으면서도 하나의 컴포넌트 객체 안에 그럭저럭 표현을 다 할 수 있도록 되어있다.

이는 곳 메타웍스의 프레임웤의 클래스 객체와 리액트 컴포넌트가 1:1 매핑 구조로 잘 돌아갈 수 있을것 같은 예감이다. 예감만..

전반적인 어플리케이션 관리 (ui 라우터나, 어플리케이션 단위의 전역 변수) 체제는 제공하지 않는데, 당장은 라이트해서 좋지만

메타웍스를 개발하면서 웬지 이 부분이 아쉬워 질 것 같은 예감이 든다.


#### UI 표현은 어찌해야하나

리액트 컴포넌트는 하나의 엘리먼트를 리턴하는 구조이고, 이 엘리먼트에 어트리뷰트를 몇가지 붙이고 이벤트를 붙이는게 전부다.

그런데 먄약 부트스트랩을 적용한 컴포넌트를 생성한다고 가정해보면, 위의 Comment 컴포넌트를 예쁘게 포장하여 UI를 그려준다고 하면 


```
var Comment = React.createClass({
    rawMarkup: function() {
        var rawMarkup = marked(this.props.children.toString(), {sanitize: true});
        return { __html: rawMarkup };
    },
    render: function() {
        return (
            <div class="row margin-bottom-10">
                <div class="col-sm-4">
                    <div className="service-block service-block-default comment">
                        <i class="icon-custom rounded icon-color-dark icon-line icon-badge"></i>
                        <h2 className="commentAuthor heading-md">
                            {this.props.author}
                        </h2>
                        <span dangerouslySetInnerHTML={this.rawMarkup()} />
                    </div>
                </div>
            </div>
        );
    }
});

```
보다시피 컴포넌트 생성 과정에서 부트스트랩 코드가 끼어들어가게 되버린다.

마테웍스가 서버에서 js 를 생성해서 던져주면, 클라이언트 개발자가 js 를 활용하여 자유도 있게 하고싶은 ui프레임워크를 선택하여 개발 할 수 있도록

해 줘야 하는데, 리액트로 방법이 있나 모르겠다.

일단은 위의 난해한 부트스트랩 코드를 리액트에 적용시키기 힘들다고 다수가 생각했는지 이런게 나와있다.

 - [React-Bootstrap](http://react-bootstrap.github.io/components.html#overlays)
 
 
코드는 이런식이다.
 
```
const buttonsInstance = (
  <div>
    <ButtonToolbar>
      <Button bsStyle="primary" bsSize="large">Large button</Button>
      <Button bsSize="large">Large button</Button>
    </ButtonToolbar>
    <ButtonToolbar>
      <Button bsStyle="primary">Default button</Button>
      <Button>Default button</Button>
    </ButtonToolbar>
    <ButtonToolbar>
      <Button bsStyle="primary" bsSize="small">Small button</Button>
      <Button bsSize="small">Small button</Button>
    </ButtonToolbar>
    <ButtonToolbar>
      <Button bsStyle="primary" bsSize="xsmall">Extra small button</Button>
      <Button bsSize="xsmall">Extra small button</Button>
    </ButtonToolbar>
  </div>
);

ReactDOM.render(buttonsInstance, mountNode);

```

리액트 최신버전에는 react-bootstrap 이 합쳐졌다.
 

혹시 material 디자인도 리액트로 나왔나 해서 검색해봤더니 있다.

 - [material-ui](http://www.material-ui.com/#/)
 
마테리얼 디자인은 구글계열의 어플리케이션 구성의 기본 디자인 프레임웤이다.

원래 마테리얼을 구현하려면 엘리먼트의 뎁쓰가 많이 발생해서 리액트로 코드짜기가 좀 어려울텐데 위에 사이트는 최대한 많은 디자인 컴포넌트를 한개의 엘리먼트로
 
구현할 수 있도록 해놓았다.


부트스트랩,  마테리얼 두가지 정도 구현할 수 있게 해주면 적당하지 않을까...?

추가적인 테마가 필요하다면 알아서 클래스 넣고 css 짜겠지.






